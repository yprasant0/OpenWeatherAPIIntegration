exit
response = fetch_data(end_point, method: :get, options: options)
c
described_class.geocode(query_params)
exit
response
exit
api_response.to_h
api_response.to_hash
api_response
api_response['list'].first['dt']
c!
c
exit
location.air_qualities.create!(air_quality_data)
air_quality_data
exit
air_quality_data
location.air_qualities.create!(air_quality_data)
location
c
 create_air_quality_record(location, air_quality_data)
air_quality_data = parse_response(response)
response.present?
c
AirQualityService.fetch_air_quality(location.latitude, location.longitude)
c!
exit
AirQualityService.fetch_air_quality(location.latitude, location.longitude)
c
response.biody
response
c
described_class.import_all_locations
c!
location
c
described_class.import_all_locations
c!
url
response = send(method, url, options)
c
api_key
c!
exit
send(method, url, options)
url
c
url
c
stub_request(:get, /air_pollution/)
            .to_return(status: 200, body: api_response, headers: {})
send(method, url, options)
url
c
base_uri
exit
response
exit
response
c
response
c
@response_code
c!
c
url
c
exit
headers['x-ratelimit-remaining']
headers['x-ratelimit-remaining'].first.to_i
headers = response.to_hash
response.to_hash
h = response.headers
check_rate_limit(response.headers)
response = send(method, url, options)
exit
c
c!
c1
c
response
c
exit
options
response.body
response = send(method, url, options)
c
response
c
response
c
response.body
c
exit
response.body
c
exit
response.body
fetch_data('/history', options: { query: query })
c
base_uri
url
exit
url
response = send(method, url, options)
exit
c
response.body
 response = send(method, url, options)
exit
base_uri
url
send(method, url, options)
url
exit
response
exit
response
c
exit
response = fetch_data(end_point, method: :get, options: options)
c
e
c
e
c
e
c
 response.code
attempt
e
exit
response = fetch_data(end_point, method: :get, options: options)
c
e
c
e.message
c
url, attempt, response.code, response.body
raise FetchDataError.new(url, attempt, response.code, response.body)
c
"Failed to fetch #{url} after #{attempt} attempts."
c
exit
response = send(method, url, options)
url
exit
c
exit
c
response = send(method, url, options)
url
c
exit
url
c
exit
c
exit
c
url
c
exit
ENV['GEOCODING_DATA_URI']
url = base_uri + end_point
url
send(method, url, options)
method
[:get, :post, :put, :delete].include?(method)
c
response = fetch_data(end_point, method: :get, options: options)
end_point = '/direct'
options = { query: { q: query_params[:q], appid: open_weather_api_key, limit: 1 } }
c
GeocodingService.geocode(query_params)
c
JSON.parse(response.body)
response.success?
response = get(endpoint, query: query)
ENV['OPEN_WEATHER_MAP_API_KEY']
c
ENV['OPEN_WEATHER_MAP_API_KEY']
response = get(endpoint, query: query)
c
request('http://api.openweathermap.org/geo/1.0' + endpoint, query)
exit
request('http://api.openweathermap.org/geo/1.0' + endpoint, query)
